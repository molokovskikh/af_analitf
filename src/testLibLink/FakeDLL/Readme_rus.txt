     +------------------------------------------+
     |                                          |
     |   TFakeDll v1.1 (Beta 2) by Dr.Golova.   |
     |                                          |
     +------------------------------------------+

I.   Что это такое и зачем нужно.
II.  Как использовать.
III. Ограничения.
IV.  Новое в этой версии.
V.   Как со мной связаться.


I. Что это такое и зачем нужно.
===============================

TFakeDll -  это Delphi  объект, предназначенный  для внедрения  32х битных
библиотек (dll) в исполнимые файлы  (Win32 PE Exe), написанные на  Delphi.
Иногда при написании программ приходится использовать библиотеки сторонних
производителей (к примеру, библиотеки для работы с файловыми архивами), но
не хочется таскать со своим проектом чужие модули. В этом случае, конечно,
можно прилинковать эти dll к файлу и перед их использованием копировать их
на диск, и  уже оттуда подгружать.  Это простой, но  не слишком элегантный
подход.  TFakeDll   позволяет  (по   крайней  мере   пробует)  "прицепить"
библиотеку  к  ехе  файлу,  и  дает  методы  для  его  использования   без
промежуточного  копирования  на  диск.  Если  быть  кратким,  то  TFakeDll
выполняет работу  стандартного загрузчика  Windows -  этот объект копирует
прилинкованную dll в память, настраивает ей импорт, релоки и предоставляет
методы для работы с экспортируемыми функциями этой dll.

II. Как использовать.
=====================

TFakeDll имеет 2 свойства - FDHandle и ShowErrors.

1) FDHandle после размапливания и настройки dll будет содержать адрес ее
   MZ заголовка,
2) ShowErrors это флажок, если он True то в случае ошибок обьект покажет
   MessageBox с кратким описанием, а если False - просто тихо умрет.

TFakeDll предоставляет всего 2 метода - InjectDll и GetFDProcAddress.

1) procedure InjectDll(MemoryFile : Pointer; FreeOld : LongBool);
   Используется для загрузки и настройки библиотеки в памяти.  MemoryFile 
   - указатель на адрес MZ заголовка не настроенной (идентичной образу dll
   на диске) dll в памяти, т.е. если образ файла в программе представлен в
   виде массива байт - надо указать его первый элемент, а если dll лежит в
   ресурсах  -  то  адрес,  по которому  будет  лежать  первый  байт этого
   ресурса. Не забывайте, что dll в файле можно пожать/зашифровать  любыми
   методам (в т.ч.  и обычными EXE  пакерами, например UPX),  и тогда надо
   указывать      адрес     буфера,      куда     предварительно      была
   распакована/расшифрована   библиотека.  FreeOld   указывает,  надо   ли
   освобождать память которая использовалась для предыдущего размапливания
   (если объект используется для нескольких библиотек) - рекомендую всегда
   ставить в true,  хотя кто знает...  Для примитивного превращения  файла
   библиотеки в массив,  который можно легко  прицепить к программе  можно
   использовать  dll_dump.exe  из  директории  Toolz,  надеюсь,  не   надо
   рассказывать как юзать этот дампер.
2) function  GetFDProcAddress(ProcName :PChar) : Pointer;
   Это аналог  стандартного GetProcAddress  но предназначен  для работы  с
   виртуальной dll. ProcName должен  содержать имя функции при  импорте по
   имени  (имя чувствительно  к регистру!)  или содержать  Ordinal нужной
   функции. Возвращает естественно адрес заказанной функции в длл, ил ноль
   в случае ошибки. Ahtung!  Export Forwarding НЕ поддерживается,  ибо мне
   лениво.

Более подробно смотрите в примере в директории Examples.

III. Ограничения.
=================

Как минимум одно - ни в самой  виртуальной dll, ни в в самой программе  по
отношению к этой dll нельзя использовать API функции с параметром  hModule
- система  не считает  расмапленную моим  объектом dll  за нормальную dll,
поэтому  функции  будут просто  возвращать  код ошибки.  К  примеру нельзя
использовать  стандартную  функцию  GetProcAddress  для  получения адресов
функций в FakeDll и нельзя использовать LoadResource из самой dll. По этой
же  причине импортировать  функции фэйковая  длл может  только из  модулей
загруженных стандартными  средствами. Ограничение  серьезное, но  ничем не
лечится.

IV.  Новое в этой версии.
=========================

v1.1:
1) Ядро переписано на C++ - как следствие увеличена скорость работы.
2) Все теперь в отдельном obj файле - линкуется с любой версией Delphi.
3) Переписана работа с ошибками - теперь обьект кидается сообщениями сам.
4) GetFDProcAddress теперь имеет один параметр, т.е. сама разбирает где
   ординалы а где строки.

v0.01
Глюкавая бета, внимания не заслуживает :)

V. Как со мной связаться.
==========================

О найденных багах, фичах и просто с жалобами/предложениями можно отписать
мне на мыло: dr_golova@pisem.net

== by Dr.Golova [mailto: dr_golova@pisem.net] ================ 01.06.02 ===
== [c] Underground Information Center [ http://www.uinc.ru ]===============
